## Скользящий контроль LOO ##

Данная процедура помогает найти оптимальное значение параметров **k** (KNN, KWNN) и **q** (весовая функция для KWNN). Для каждого объекта из выборки проверяется, правильно ли он классифицируется по своим k ближайшим соседям (k = [1; l], q = (0; 1)).

### Реализация скользящего контроля LOO для KNN ###
``` r
# Параметры: выборка и метод, который используют для классификации
LOO <- function(xl, alg = KNN ){
    
    # Инициализация вектора для LOO
    MLOO <- matrix(0, dim(xl)[1] - 1, 1)
    l <- dim(xl)[1]
    
    for (i in 1:l){
        # Берем точку из выборки и переопределяем выборку
        point <- c(xl[i,1:2])
        newXl <- xl[-i,]
        
        # Сортируем выборку
        ordXl <- sortByDist( point, newXl )
        
        for (k in 1:(l - 1)){
            # Сравнение работы алогоритма и класса исключенной точки
            if( alg(point, ordXl, k ) != xl[i, 3] ){

                # Если алгоритм ошибся, то штрафуем его
                MLOO[k][1] <-  MLOO[k][1] + (1/l)
            }
        }
    }
    # Выбираем оптимальный k
    min <- which.min(MLOO)
    return(min)
}
```

<img src="https://user-images.githubusercontent.com/71149650/94484221-bf626500-01e4-11eb-87f9-24c663d2970b.png" alt="LOO для полной выборки" />

### Реализация скользящего контроля LOO для KWNN ###
В данной функции идет поиск оптимального **k** и **q** одновременно.

``` r
# Параметры: выборка и метод, который используют для классификации
LOO <- function(xl, alg = KWNN ){
    l <- dim(xl)[1]

    # Определяем рамки для поиска значения весовой функции
    r1 <- 0.02
    r2 <- 0.98
  
    # Инициализация матрицы для LOO
    MLOO <- matrix(0, l - 1, r2 / r1 )

    for (i in 1:l) {
    
        # Берем точку из выборки и переопределяем выборку 
        point <- c(xl[i,1:2])
        new_iris <- xl[-i,]
        
        # Сортируем выборку
        ordXl <- sortByDist( point, new_iris )
        
        # Цикл по k
        for (k in 1:(l - 1)) {
            j <- 1
              
            # Цикл по q
            for (q in seq(r1, r2, r1 ) ) {
            
                # Сравнение работы алогоритма и класса исключенной точки
                if ( alg(point,  ordXl, k, q ) != xl[i, 3] ) {
                    
                    # Если алгоритм ошибся, то штрафуем его
                    MLOO[k,j] <-  MLOO[k,j] + 1/l
                      
                }
                    
                j <- j + 1 
                   
            }

        }
    
    }
    
    # Находим минимальное значение в матрице(столбец и строку минимального значения)
    q <- which.min(MLOO) %/% (dim(xl)[1] - 1) + 1
    k <- which.min(MLOO) %% (dim(xl)[1] - 1)
   
    # Возвращаем найденные оптимальные параметры 
    return(c(q, k))
}  
```

<img src="https://user-images.githubusercontent.com/71149650/95449907-1945f600-096e-11eb-9310-ea6a8523d001.png" />

### Реализация скользящего контроля LOO для парзеновского окна ###
В данной функции идет поиск оптимального **h** - радиус окна.

``` r
# Параметры: выборка и метод, который используют для классификации
LOO <- function(xl, alg = Parz){
    l <- dim(xl)[1]
    
    # Инциализация вектора для перебора радиуса окна и вектора для LOO
    h <- seq(0.1, 2, 0.1)
    MLOO <- matrix(0, length(h), 1)
  
    for (i in 1:l) {
    
        # Берем точку из выборки и переопределяем выборку с расстояниями
        point <- c(xl[i, 1:2])        
        dist <- Dist(point, xl[-i,])
        
        for (j in 1:length(h) ) {
        
            # Сравнение работы алогоритма и класса исключенной точки
            if (alg(point, dist, h[j]) != xl[i, 3]) {
            
                # Если алгоритм ошибся, то штрафуем его
                MLOO[j][1] <-  MLOO[j][1] + 1 / l
            }  
          
        }
        
    }
    
    # Выбираем оптимальный h и возваращаем его
    min <- which.min(MLOO)
    return(min)  
}
```
Все графики LOO для парзеновского окна находятся в разделе данного метода. [ссылка будет]


## Сравнительная таблица ##

<table>
    <tr>
        <td>Метрический метод</td>
        <td>Параметры</td>
        <td>Значение LOO</td>
    </tr>
    <tr>
        <td>1NN</td>
        <td> - </td>
        <td>0.046</td>
    </tr>
    <tr>
        <td>KNN</td>
        <td>k = 6</td>
        <td>0.034</td>
    </tr>
    <tr>
        <td>KWNN</td>
        <td>k = 30, q = 0.96</td>
        <td>0.034</td>
    </tr>
     <tr>
        <td rowspan = "5">Парзеновское окно</td>
        <td>Прямоугольное ядро, h = 0.4</td>
        <td>0.04</td>
    </tr>
    <tr>
        <td>Треугольное ядро, h = 0.4</td>
        <td>0.04</td>
    </tr>
    <tr>
        <td>Ядро Епанечникова, h = 0.4</td>
        <td>0.04</td>
    </tr>
    <tr>
        <td>Квартическое ядро, h = 0.4</td>
        <td>0.04</td>
    </tr>
    <tr>
        <td>Гауссовское ядро, h = 0.1</td>
        <td>0.04</td>
    </tr>
</table>

Анализируя данные в таблице, прийдем к выводу, что самым опимальным алгоритмом для ирисов фишер будет:
+ по кол-ву ошибок на выборке - **KNN**
+ по параметру метода - **Парзеновское окно** с гауссовским ядром

Таким образом, если главное при выполнении задачи - минимазация ошибок, то лучше выбрать **KNN**, если же скорость работы - **Парзеновское окно** с гауссовским ядром.

